#!/usr/bin/env python
"""Command line tool for sending test data for Ceilometer via oslo.messaging.

Usage:

Send messages with samples generated by make_test_data

source .tox/py27/bin/activate
./tools/send_test_data.py --count 1000 --resources_count 10 --topic metering
"""
import argparse
import binascii
import copy
import datetime
import functools
import os
import time
import uuid

import oslo_messaging
from oslo_utils import timeutils

from ceilometer import messaging
from ceilometer import service


def send_batch_notifier(notifier, topic, batch):
    notifier.sample({}, event_type=topic, payload=batch)


def get_notifier(config_file):
    #service.prepare_service(argv=['/', '--config-file', config_file])
    return oslo_messaging.Notifier(
        messaging.get_transport(service.prepare_service(argv=['/', '--config-file', config_file])),
        driver='messagingv2',
        publisher_id='telemetry.publisher.test',
        topics=['metering'],
    )

MESSAGE_ID = uuid.uuid4().hex

metadata = {
    'status': 'ok',
    'state': 'ok',
    'display_name': 'host',
    'instance_host': 'host',
    'container_format': 'x',
    'min_ram': '1',
    'disk_format': 'x',
    'instance_id': 'x',
    'instance_type': 'x',
    'host': 'hostname',
    'protected': 'yes',
    'checksum': 'all',
    'is_public': 'no',
    'size': '1',
}

sample = {
    'source': 'artificial',
    'counter_name': '???',
    'counter_type': 'gauge',
    'counter_unit': "%",
    'counter_volume': 1,
    'user_id': None,
    'project_id': 'b1ab0a6a260b4df88b3ea2d891c01bce',
    'resource_id': None,
    'timestamp': None,
    'resource_metadata': metadata,
    'message_id': MESSAGE_ID,
}


def get_sample(meter, resource, timestamp, stack_id):
    s = copy.copy(sample)
    s['counter_name'] = meter
    s['resource_id'] = resource
    s['timestamp'] = timestamp.isoformat()
    s['resource_metadata']['display_name'] = resource
    s['resource_metadata']['checksum'] = stack_id
    return s


def generate_data(send_batch, batch_size, resources_count,
                  meters_count, topic, interval, start, end, user_id, project_id, stack_id, rfile):

    resources_list = []
    with open(rfile) as infile:
        for i in infile:
            r = i.strip()
            if r:
                resources_list.append(r)
    print len(resources_list)

    # !!! Uncomment this if you don't need to use predefined list of resources from file !!!
    '''resources_list = [str(uuid.uuid4())
                      for _ in xrange(resources_count)]'''
    meters_list = ['test_meter_' + str(i) for i in range(meters_count)]

    time_delta = datetime.timedelta(seconds=interval)
    start = timeutils.parse_strtime(start)
    end = timeutils.parse_strtime(end)
    next_time = start
    # next_time = datetime.datetime.utcnow() - datetime.timedelta(hours=start)
    first_start_time = datetime.datetime.utcnow()
    
    count = 0    
    print next_time, end
    try:
        while True:
            if next_time > end:
                break
            while datetime.datetime.utcnow() < next_time:
                time.sleep(
                    (next_time - datetime.datetime.utcnow()).total_seconds())
            print('Next sending time: %s.' % (next_time))
            print next_time.isoformat()
            
            batch = []
            print('Adding new samples for timestamp %s.' % (next_time))
            
            for meter in meters_list:
                for resource in resources_list:
                    count += 1
                    sample = get_sample(meter, resource, next_time, stack_id)
                    batch.append(sample)
                    if len(batch) == batch_size:
                        send_batch(topic, batch)
                        batch = []
                
                send_batch(topic, batch) # send leftovers which size is smaller than "batch_size" arg value
                batch = []
            

            next_time = next_time + time_delta
            print('\nTotal sum of sent samples - %d' % (count))
            print('%s seconds passed since script was executed.' % (datetime.datetime.utcnow() - first_start_time).total_seconds())
    except KeyboardInterrupt:
        print('\nAdded %d samples.' % (count))
        print('%s seconds passed since script was executed.' % (datetime.datetime.utcnow() - first_start_time).total_seconds())
        return 0
    return 0

def get_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--batch-size',
        dest='batch_size',
        type=int,
        default=100
    )
    parser.add_argument(
        '--config-file',
        default='/etc/ceilometer/ceilometer.conf'
    )
    parser.add_argument(
        '--topic',
        default='metering'
    )
    parser.add_argument(
        '--resources-count',
        dest='resources_count',
        type=int,
        default=10
    )
    parser.add_argument(
        '--meters-count',
        dest='meters_count',
        type=int,
        default=25
    )
    parser.add_argument(
        '--result-directory',
        dest='result_dir',
        default='/tmp'
    )
    parser.add_argument(
        '--interval',
        default=60,
        type=int,
        help='The period between samples, in seconds.',
    )
    parser.add_argument(
        '--start',
        default=24,
        help='Number of hours to be stepped back from now or date in the past ('
             '"YYYY-MM-DDTHH:MM:SS" format) to define timestamps start range.',
    )
    parser.add_argument(
        '--end',
        default=0,
        help='Number of hours to be stepped back from now or date in the past ('
             '"YYYY-MM-DDTHH:MM:SS" format) to define timestamps end range.',
    )
    parser.add_argument(
        '--project',
        dest='project_id',
        help='Project id of owner.',
    )
    parser.add_argument(
        '--user',
        dest='user_id',
        help='User id of owner.',
    )
    parser.add_argument(
        '--stack',
        default='xxxxxx',
        dest='stack_id',
        help='id of stack.',
    )
    parser.add_argument(
        '--rfile',
        default='resources.txt',
        dest='rfile',
        help='file with resource ids.',
    )
    return parser


def main():
    args = get_parser().parse_known_args()[0]

    notifier = get_notifier(args.config_file)
    send_batch = functools.partial(send_batch_notifier, notifier)

    del args.config_file
    del args.result_dir

    generate_data(send_batch, **args.__dict__)

if __name__ == '__main__':
    main()
